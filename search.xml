<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AVL Tree</title>
    <url>/article/avl-tree/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基于AVL算法的自平衡二叉搜索是二叉搜索树的一个优化算法，本文所述AVL树基于BST基础上优化，如果BST树还没有了解过可以先看<strong><a href="https://vincent-vic.gitee.io/article/binarysearchtree/">《二分搜索树》</a></strong></p>
<h2 id="平衡二叉树的概念"><a href="#平衡二叉树的概念" class="headerlink" title="平衡二叉树的概念"></a>平衡二叉树的概念</h2><h3 id="什么是平衡二叉树"><a href="#什么是平衡二叉树" class="headerlink" title="什么是平衡二叉树"></a>什么是平衡二叉树</h3><p>引用维基百科的介绍</p>
<blockquote>
<p>在计算机科学中，AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log(n))。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者G. M. Adelson-Velsky和Evgenii Landis，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。</p>
<p>节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p>
</blockquote>
<p>如果二叉搜索树出现了有序的插入情况，那么就会出现图片这样的最坏情况（退化到链表结构）</p>
<p><img src="/" alt="二叉搜索树最坏情况" class="lazyload" data-src="/images/AVL/base01/01.png"></p>
<p>AVL平衡二叉树是普通二叉搜索树经典优化的一个算法思想</p>
<h3 id="AVL-特性"><a href="#AVL-特性" class="headerlink" title="AVL 特性"></a>AVL 特性</h3><p><img src="/" alt="AVL" class="lazyload" data-src="/images/AVL/base01/02.png"></p>
<p><strong>1.AVL 左右子树高度相差不能超过1</strong></p>
<p><strong>2.平衡二叉树的高度和节点数量致敬的关系为O(logn)</strong></p>
<p>这样一棵二叉树就不是平衡二叉树</p>
<p><img src="/" alt="非平衡二叉树" class="lazyload" data-src="/images/AVL/base01/03.png"></p>
<h3 id="AVL主要思路"><a href="#AVL主要思路" class="headerlink" title="AVL主要思路"></a>AVL主要思路</h3><blockquote>
<p>AVL树的基本操作一般涉及运作同在不平衡的二叉查找树所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的”AVL旋转”。</p>
<p>以下图表以四列表示四种情况，每行表示在该种情况下要进行的操作。在左左和右右的情况下，只需要进行一次旋转操作；在左右和右左的情况下，需要进行两次旋转操作。</p>
</blockquote>
<p><img src="/" alt="AVL主要思路" class="lazyload" data-src="/images/AVL/base01/Tree_Rebalancing.png"></p>
<h2 id="AVL维护自平衡算法"><a href="#AVL维护自平衡算法" class="headerlink" title="AVL维护自平衡算法"></a>AVL维护自平衡算法</h2><p>什么时候维护？</p>
<p><img src="/" alt="什么时候维护" class="lazyload" data-src="/images/AVL/base01/04.png"></p>
<p>在加入删除节点时都可能破坏平衡，所以需要在添加节点时加入自平衡机制</p>
<p>那么先来看看AVL算法的整体机制，再来分解算法：</p>
<p><img src="/" alt="添加时维护" class="lazyload" data-src="/images/AVL/base01/01.gif"></p>
<p>添加时维护</p>
<p><img src="/" alt="删除时维护" class="lazyload" data-src="/images/AVL/base01/02.gif"></p>
<p>删除时维护</p>
<p>从动图中我们可以发现维护平衡时不断的在向上回溯的检查平衡因子，当因子打破平衡时进行了一系列的维护操作。</p>
<p>那我们AVL的算法程序就直接在二分搜索树中标记节点高度和计算平衡因子，为后续算法提供依据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算平衡因子</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> getHeight(node-&gt;left) - getHeight(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>//在Node中加入height标记节点高度（本文实现初始化为1）</p>
<p>//在原有BST基础上插入中加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;更新height -- AVL</span><br><span class="line">&#x2F;&#x2F; 高度为左右子节点高度最大值加1</span><br><span class="line">node-&gt;height &#x3D;  1 + max(getHeight(node-&gt;left),getHeight(node-&gt;right));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="AVL-算法"><a href="#AVL-算法" class="headerlink" title="AVL 算法"></a>AVL 算法</h3><p>面对非平衡的算法</p>
<p><img src="/" alt="非平衡二叉树" class="lazyload" data-src="/images/AVL/base01/03.png"></p>
<p>AVL算法分为RR,LL,LR,RL四种情况</p>
<h3 id="RR-右旋"><a href="#RR-右旋" class="headerlink" title="RR 右旋"></a>RR 右旋</h3><p><img src="/" alt="RR" class="lazyload" data-src="/images/AVL/base01/05.png"></p>
<p>失衡节点为节点y,失衡节点节点的左节点x，步骤：把失衡节点加入到x的右节点，x原本右节点的加入到y的左节点</p>
<p>完成操作之后需要更新y,x节点,这里y需要先更新，再更新x</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对节点y进行向右旋转操作，返回旋转后新的根节点x</span></span><br><span class="line"><span class="comment">//        y                              x</span></span><br><span class="line"><span class="comment">//       / \                           /   \</span></span><br><span class="line"><span class="comment">//      x   T4     向右旋转 (y)        z     y</span></span><br><span class="line"><span class="comment">//     / \       - - - - - - - -&gt;    / \   / \</span></span><br><span class="line"><span class="comment">//    z   T3                       T1  T2 T3 T4</span></span><br><span class="line"><span class="comment">//   / \</span></span><br><span class="line"><span class="comment">// T1   T2</span></span><br><span class="line"><span class="function">Node* <span class="title">rightRotate</span><span class="params">(Node* y)</span></span>&#123;</span><br><span class="line">    Node* x = y-&gt;left;</span><br><span class="line">    Node* T3 = x-&gt;right;</span><br><span class="line"></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = T3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新height</span></span><br><span class="line">    y-&gt;height = max(getHeight(y-&gt;left),getHeight(y-&gt;right)) + <span class="number">1</span> ;</span><br><span class="line">    x-&gt;height = max(getHeight(x-&gt;left),getHeight(x-&gt;right)) + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="LL-左旋"><a href="#LL-左旋" class="headerlink" title="LL 左旋"></a>LL 左旋</h3><p><img src="/" alt="LL" class="lazyload" data-src="/images/AVL/base01/07.png"><br><img src="/" alt="LL" class="lazyload" data-src="/images/AVL/base01/06.png"></p>
<p>左旋跟右旋相反，失衡节点为节点y,失衡节点节点的右节点x，步骤：把失衡节点加入到x的左节点，x原本左节点的加入到y的右节点</p>
<p>完成操作之后需要更新y,x节点,这里y需要先更新，再更新x</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对节点y进行向左旋转操作，返回旋转后新的根节点x</span></span><br><span class="line"><span class="comment">//    y                             x</span></span><br><span class="line"><span class="comment">//  /  \                          /   \</span></span><br><span class="line"><span class="comment">// T1   x      向左旋转 (y)       y     z</span></span><br><span class="line"><span class="comment">//     / \   - - - - - - - -&gt;   / \   / \</span></span><br><span class="line"><span class="comment">//   T2  z                     T1 T2 T3 T4</span></span><br><span class="line"><span class="comment">//      / \</span></span><br><span class="line"><span class="comment">//     T3 T4</span></span><br><span class="line"><span class="function">Node* <span class="title">leftRotate</span><span class="params">(Node* y)</span> </span>&#123;</span><br><span class="line">    Node* x = y-&gt;right;</span><br><span class="line">    Node* T2 = x-&gt;left;</span><br><span class="line"></span><br><span class="line">    x-&gt;left = y;</span><br><span class="line">    y-&gt;right = T2;</span><br><span class="line">    <span class="comment">//更新height</span></span><br><span class="line">    y-&gt;height = max(getHeight(y-&gt;left),getHeight(y-&gt;right)) + <span class="number">1</span> ;</span><br><span class="line">    x-&gt;height = max(getHeight(x-&gt;left),getHeight(x-&gt;right)) + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="RR-和-LL-总结"><a href="#RR-和-LL-总结" class="headerlink" title="RR 和 LL 总结"></a>RR 和 LL 总结</h3><p><img src="/" alt="LL&amp;RR" class="lazyload" data-src="/images/AVL/base01/08.png"></p>
<p>这样的情况只要通过左旋和右旋来就可以解决</p>
<p><img src="/" alt="LL&amp;RR" class="lazyload" data-src="/images/AVL/base01/09.png"></p>
<p>图中的出现在左边的右边节点造成因素，就不能直接右旋转，因为这样会导致搜索树不满足性质。AVL的最后两种算法</p>
<hr>
<h3 id="LR-先左旋再右旋"><a href="#LR-先左旋再右旋" class="headerlink" title="LR 先左旋再右旋"></a>LR 先左旋再右旋</h3><p><img src="/" alt="LR" class="lazyload" data-src="/images/AVL/base01/10.png"><br><img src="/" alt="LR" class="lazyload" data-src="/images/AVL/base01/11.png"></p>
<h3 id="RL-先右旋再左旋"><a href="#RL-先右旋再左旋" class="headerlink" title="RL 先右旋再左旋"></a>RL 先右旋再左旋</h3><p><img src="/" alt="RL" class="lazyload" data-src="/images/AVL/base01/12.png"><br><img src="/" alt="RL" class="lazyload" data-src="/images/AVL/base01/13.png"></p>
<h3 id="LR-和-RL-实现"><a href="#LR-和-RL-实现" class="headerlink" title="LR 和 RL 实现"></a>LR 和 RL 实现</h3><p>这里直接调用实现好的左旋和右旋</p>
<h2 id="维护平衡的整体实现"><a href="#维护平衡的整体实现" class="headerlink" title="维护平衡的整体实现"></a>维护平衡的整体实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 维护AVL平衡</span></span><br><span class="line"><span class="comment"> * @param node 失衡节点</span></span><br><span class="line"><span class="comment"> * @return 返回维护后的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node* <span class="title">retainAVL</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">//更新height -- AVL</span></span><br><span class="line">    <span class="comment">// 高度为左右子节点高度最大值加1</span></span><br><span class="line">    node-&gt;height =  <span class="number">1</span> + max(getHeight(node-&gt;left),getHeight(node-&gt;right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算平衡因子</span></span><br><span class="line">    <span class="keyword">int</span> balaceFactor = getBalanceFactor(node);</span><br><span class="line">    <span class="comment">//左侧产生的失衡 LL</span></span><br><span class="line">    <span class="keyword">if</span>(balaceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node-&gt;left) &gt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);<span class="comment">//右旋转</span></span><br><span class="line">    <span class="comment">//右侧产生的失衡 RR</span></span><br><span class="line">    <span class="keyword">if</span>(balaceFactor &lt; <span class="number">-1</span> &amp;&amp; getBalanceFactor(node-&gt;right) &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> leftRotate(node);<span class="comment">//左旋转</span></span><br><span class="line">    <span class="comment">//左侧的右侧产生的失衡 LR</span></span><br><span class="line">    <span class="keyword">if</span>(balaceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node-&gt;left) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        node-&gt;left = leftRotate(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//右侧的左侧产生的失衡 RL</span></span><br><span class="line">    <span class="keyword">if</span>(balaceFactor &lt; <span class="number">-1</span> &amp;&amp; getBalanceFactor(node-&gt;right) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        node-&gt;right = rightRotate(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下只需要在inster,remove,removeMax，removeMin中添加维护功能即可，这样就将普通的二叉搜索树修改成自平衡的二叉搜索树（AVL算法）</p>
<hr>
<h2 id="附加功能"><a href="#附加功能" class="headerlink" title="附加功能"></a>附加功能</h2><p>也实现了判断是否BST和是否平衡两个小功能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断以Node为根的二叉树是否是一颗平衡二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(balanceFactor) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isBalanced(node-&gt;left) &amp;&amp; isBalanced(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否是一棵二叉搜索树</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBST</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Key&gt; keys;</span><br><span class="line">    inOrder(keys);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; keys.size(); ++i)</span><br><span class="line">        <span class="keyword">if</span> (keys[i] &lt; keys[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细代码欢迎访问gitee中查看：<a href="https://gitee.com/Vincent-Vic/DataOrganization/tree/master/BinarySearch" target="_blank" rel="noopener">AVL实现</a></p>
<p>有什么问题欢迎大佬指出</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>全国哀悼4月4日,为抗击疫情的战士们降半旗！</title>
    <url>/article/stand-in-silent-tribite/</url>
    <content><![CDATA[<p><img src="/" alt="" class="lazyload" data-src="/images/4.4.png"></p>
<p><a href="http://www.gov.cn/zhengce/content/2020-04/03/content_5498474.htm" target="_blank" rel="noopener"><img src="/" alt="" class="lazyload" data-src="/images/4.4txt.jpg"></a></p>
]]></content>
      <categories>
        <category>默哀</category>
      </categories>
      <tags>
        <tag>向英雄致敬</tag>
      </tags>
  </entry>
  <entry>
    <title>堆与堆排序</title>
    <url>/article/heap-and-sort/</url>
    <content><![CDATA[<h2 id="优先队列？"><a href="#优先队列？" class="headerlink" title="优先队列？"></a>优先队列？</h2><p>普通队列：先进先出；后进后出</p>
<p>优先队列：出队和入队顺序无关；和优先级相关</p>
<h5 id="操作系统的优先队列"><a href="#操作系统的优先队列" class="headerlink" title="操作系统的优先队列"></a>操作系统的优先队列</h5><p>操作系统任务执行–动态选择</p>
<p>动态加入任务，每次排序？？？</p>
<h5 id="游戏自动打怪"><a href="#游戏自动打怪" class="headerlink" title="游戏自动打怪"></a>游戏自动打怪</h5><p>游戏角色自动打怪是否能更优先队列相关？先打血少的还是先打近的？还是漫无目的的</p>
<h5 id="排名问题"><a href="#排名问题" class="headerlink" title="排名问题"></a>排名问题</h5><p>1000000 人总，怎么得到前100名</p>
<p>在N个元素中选出前M个元素</p>
<p>排序？ <em>O(nlogn)</em></p>
<p>使用优先队列可以快多少？<em>O(nlogm)</em></p>
<h5 id="总而言之"><a href="#总而言之" class="headerlink" title="总而言之"></a>总而言之</h5><p>优先队列出队按最高优先级最高</p>
<h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><blockquote>
<p>堆(Heap))是一种重要的数据结构，是实现优先队列(Priority Queues)首选的数据结构。由于堆有很多种变体，包括二项式堆、斐波那契堆等，但是这里只考虑最常见的就是二叉堆（以下简称堆）。</p>
<p>堆是一棵满足一定性质的二叉树，具体的讲堆具有如下性质：父节点的键值总是不大于它的孩子节点的键值（小顶堆）</p>
</blockquote>
<p>堆可以分为小顶堆和大顶堆，这里以小顶堆为例，其主要包含的操作有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert()</span><br><span class="line">extractMin</span><br><span class="line">peek(findMin)</span><br><span class="line">delete(i)</span><br></pre></td></tr></table></figure>

<p>由于堆是一棵形态规则的二叉树，因此堆的父节点和孩子节点存在如下关系：</p>
<p>设父节点的编号为 i, 则其左孩子节点的编号为2 * i+1, 右孩子节点的编号为2 * i+2<br>设孩子节点的编号为i, 则其父节点的编号为(i-1)/2</p>
<h2 id="二叉树堆"><a href="#二叉树堆" class="headerlink" title="二叉树堆"></a>二叉树堆</h2><p><img src="/" alt="二叉树堆" class="lazyload" data-src="/images/heap/base1/heap01.png"></p>
<h4 id="二叉树堆是一颗完全二叉树"><a href="#二叉树堆是一颗完全二叉树" class="headerlink" title="二叉树堆是一颗完全二叉树"></a>二叉树堆是一颗完全二叉树</h4><p>堆中某个节点的值总是不大于其父节点的值；堆总是一棵完成二叉树。（最大堆）</p>
<p>由于堆是一颗完全二叉树，实现可以采用数组实现</p>
<h4 id="数组实现二叉堆树"><a href="#数组实现二叉堆树" class="headerlink" title="数组实现二叉堆树"></a>数组实现二叉堆树</h4><p><img src="/" alt="二叉树堆" class="lazyload" data-src="/images/heap/base1/heap02.jpg"></p>
<p>二叉堆树采用数组实现</p>
<pre><code>| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| ----- | -----: | :----: | :----:| :----:| :----:| :----:| :----:| :----:| :----:| :----:|
| - | 90 | 36 | 26 | 25 | 19 | 17 | 1 | 7 | 3 | 2 |</code></pre><p>这里第0号空间为了实现直观经典</p>
<p>父节点：parent (i) = i / 2</p>
<p>左节点：left child (i) = 2 * i</p>
<p>右节点：right child (i) = 2 * i + 1</p>
<p>使用0号空间</p>
<blockquote>
<p>父节点：parent (i) = (i-1) / 2</p>
<p>左节点：left child (i) = 2 * i +1 </p>
<p>右节点：right child (i) = 2 * i + 2</p>
</blockquote>
<p>来吧边写代码边理解！！！</p>
<p>文中不具体描述的声明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Item&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Item* data;</span><br><span class="line">    <span class="keyword">int</span> count ;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxHeap(<span class="keyword">int</span> capacity);</span><br><span class="line">    <span class="keyword">virtual</span> ~MaxHeap();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><img src="/" alt="插入操作" class="lazyload" data-src="/images/heap/base1/heap03.gif"></p>
<p>如果插入的新节点已经满足二叉堆的性质的情况</p>
<p><img src="/" alt="插入操作" class="lazyload" data-src="/images/heap/base1/heap04.gif"></p>
<p>插入节点破坏二叉堆性质的情况</p>
<h4 id="思路分解"><a href="#思路分解" class="headerlink" title="思路分解"></a>思路分解</h4><p>步骤：</p>
<ol>
<li>插入到末尾</li>
<li>调整位置 – Shift UP 向上调整(细品动图)</li>
</ol>
<h5 id="Shift-UP-向上调整"><a href="#Shift-UP-向上调整" class="headerlink" title="Shift UP 向上调整"></a>Shift UP 向上调整</h5><p>这里可以看得出，插入一个元素在末尾，如果这个数大于跟节点，就不满足二叉堆的性质</p>
<p>那把如果插入节点是否大于父节点，如果大于新节点位置（父子节点交换）看成一个子问题，检查调整后的父节点，这就是插入过程中的Shift Up过程</p>
<blockquote>
<p>向上调整通过于父节点大小比较</p>
</blockquote>
<p>==Shift UP 实现代码==</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( k&gt; <span class="number">1</span> &amp;&amp; data [k / <span class="number">2</span>] &lt; data[k])&#123; <span class="comment">//判断父节是否小于k节点</span></span><br><span class="line">        <span class="built_in">std</span>::swap(data[k/<span class="number">2</span>], data[k]); <span class="comment">//调整位置</span></span><br><span class="line">        k /= <span class="number">2</span> ; <span class="comment">//进入父节点继续检查调整后的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>那么有了Shift Up那么插入就没什么难度了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( capacity == count)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//堆满这里false,也可以可以开辟新的空间</span></span><br><span class="line">        data[count++] = item; <span class="comment">//插入元素</span></span><br><span class="line">        <span class="comment">//调整位置</span></span><br><span class="line">        shiftUp(count);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><h5 id="思路分解-1"><a href="#思路分解-1" class="headerlink" title="思路分解"></a>思路分解</h5><p>步骤：</p>
<ol>
<li>取出队首</li>
<li>将队尾移动到队首</li>
<li>调整位置 – Shift Dowm (细品动图)</li>
</ol>
<p>有Up 必有Down,来吧Shift Dowm</p>
<p><img src="/" alt="出队操作" class="lazyload" data-src="/images/heap/base1/heap05.gif"></p>
<p>二话不说看图，看完图写代码</p>
<h5 id="Shift-Dowm-向下调整"><a href="#Shift-Dowm-向下调整" class="headerlink" title="Shift Dowm 向下调整"></a>Shift Dowm 向下调整</h5><p>由于到队首破坏二叉堆的性质需要调整，所以需要向下调整通过子节点比较</p>
<p><strong>代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="number">2</span>*k &lt;= count)&#123; <span class="comment">//判断是否有左孩子就说明可以继续判断</span></span><br><span class="line">            <span class="comment">// 在此轮循环中，data[k]和data[j]交换位置</span></span><br><span class="line">            <span class="comment">// 初始化为父节点与左孩子交换位置j</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="comment">//右孩子存在并且大于父节点，交换位置j改成右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(j + <span class="number">1</span> &lt;= count &amp;&amp; data[j+<span class="number">1</span>] &gt; data[j]) j ++;</span><br><span class="line">            <span class="comment">//如果父节点大于等于要交换的节点，那么无需操作</span></span><br><span class="line">            <span class="keyword">if</span>( data[k] &gt;= data[j] ) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">std</span>::swap(data[k], data[j]); <span class="comment">//调整位置</span></span><br><span class="line">            k = j ; <span class="comment">//进入子节点继续检查调整后的子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最大值代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Item <span class="title">extractMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assert( count &lt; <span class="number">0</span>); <span class="comment">//防止二叉堆中没有数据</span></span><br><span class="line">        Item ret = data[<span class="number">1</span>]; <span class="comment">//取出最大值</span></span><br><span class="line">        <span class="built_in">std</span>::swap(data[<span class="number">1</span>],data[count--]); <span class="comment">//将最后一个元素移动到队首</span></span><br><span class="line">        shiftDown(<span class="number">1</span>); <span class="comment">//向下调整</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h3><h4 id="步骤分析"><a href="#步骤分析" class="headerlink" title="步骤分析"></a>步骤分析</h4><ol>
<li>要排序的元素入堆</li>
<li>在通过取出最大堆赋值给数组</li>
</ol>
<h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><p>将n个元素逐个插入到一个空堆中，是否复杂度是O(nlogn)</p>
<p>最简单的版本1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort_V1</span><span class="params">(T arr[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    MaxHeap&lt;T&gt; maxHeap = MaxHeap&lt;T&gt;(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  <span class="comment">//将arr入二叉树堆</span></span><br><span class="line">        maxHeap.insert(arr[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)  <span class="comment">//从小的到大排序</span></span><br><span class="line">        arr[i] = maxHeap.extractMax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="版本2-Heapify"><a href="#版本2-Heapify" class="headerlink" title="版本2 Heapify"></a>版本2 Heapify</h3><p>以上由此不难发现一个问题，就是排序的时候需要依次将待排序数组元素插入，每插入一次执行一次shiftUp,以及取出时shiftDown操作动态维护堆序性。那可不可以在乱序的数组中直接把它变化成具有堆序性的数组呢？答案是肯定的，由此诞生了第二个算法，此过程被称为“Heapify”。</p>
<p><img src="/" alt="Heapify 排序" class="lazyload" data-src="/images/heap/base1/heap06.gif"></p>
<p>其原理是先把传进来的数组原封不动复制到data[]数组中，然后从堆中最后一个<strong>非叶结点至根节点开始，对扫描的每一个元素执行shiftDown操作</strong>，如上图演示</p>
<h4 id="版本2-Heapify-算法复杂度"><a href="#版本2-Heapify-算法复杂度" class="headerlink" title="版本2 Heapify 算法复杂度"></a>版本2 Heapify 算法复杂度</h4><p>Heapify 的过程算法复杂度为O(n)</p>
<p><strong>代码实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Heapify版本</span></span><br><span class="line">MaxHeap(Item arr[],<span class="keyword">int</span> n)&#123;</span><br><span class="line">    data = <span class="keyword">new</span> Item[n+<span class="number">1</span>];</span><br><span class="line">    count = capacity = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        data[i+<span class="number">1</span>] = arr[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = count / <span class="number">2</span>; i &gt;= <span class="number">1</span> ; --i)</span><br><span class="line">        shiftDown(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="简单与heapify小结版本"><a href="#简单与heapify小结版本" class="headerlink" title="简单与heapify小结版本"></a>简单与heapify小结版本</h4><p>①将n个元素插入到一个空堆中，时间复杂度是O(nlogn)。<br>②heapify过程中，时间复杂度为O(n)。<br>故在heapify过程中，降低了一定的时间复杂度。但深入到程序中，我们又会发现，在待排序数组传入构造器中时，还是先把其完整的复制到数组data[]中，heapify的过程是在data[]数组中完成的，消耗了额外的O(n)辅助空间。那可不可以直接在原始的待排序的数组上直接排序呢？答案也是肯定的，由此诞生了原地堆排序。</p>
<h3 id="版本3-原地堆排序"><a href="#版本3-原地堆排序" class="headerlink" title="版本3 原地堆排序"></a>版本3 原地堆排序</h3><p><img src="/" alt="Heapify 排序" class="lazyload" data-src="/images/heap/base1/heap07.gif"></p>
<p>代码中，①先将输入进来的待排序数组进行heapify操作，即从最后一个非叶结点到根节点遍历执行shiftDown操作，使其变成具有堆序性的数组，②然后再依次将根元素(最大的元素)与数组中最后一个堆元素交换位置，并对剩下的堆中元素执行shiftDown操作。具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//版本3 原地堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort_V3</span><span class="params">(T arr[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// heapify</span></span><br><span class="line">    <span class="comment">//(n-1) / 2 从叶子结点进行shiftDown</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (n<span class="number">-1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        shiftDown(arr,n,i);</span><br><span class="line">    <span class="comment">//从最后一个不断向前，从堆取出最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; --i)  &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[<span class="number">0</span>],arr[i]); <span class="comment">//交换第一个与最后一个</span></span><br><span class="line">        shiftDown(arr,i,<span class="number">0</span>); <span class="comment">//调整前面的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的shiftDown方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(T arr[],<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( <span class="number">2</span>*k+<span class="number">1</span> &lt; n)&#123; <span class="comment">//判断是否有左孩子就说明可以继续判断</span></span><br><span class="line">        <span class="comment">// 在此轮循环中，arr[k]arr[j]交换位置</span></span><br><span class="line">        <span class="comment">// 初始化为父节点与左孩子交换位置j</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//右孩子存在并且大于父节点，交换位置j改成右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; arr[j+<span class="number">1</span>] &gt; arr[j]) j ++;</span><br><span class="line">        <span class="comment">//如果父节点大于等于要交换的节点，那么无需操作</span></span><br><span class="line">        <span class="keyword">if</span>( arr[k] &gt;= arr[j] ) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[k], arr[j]); <span class="comment">//调整位置</span></span><br><span class="line">        k = j ; <span class="comment">//进入子节点继续检查调整后的子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="原地堆排序总结"><a href="#原地堆排序总结" class="headerlink" title="原地堆排序总结"></a>原地堆排序总结</h4><p>由此可看出，原地堆排序既无需过多额外辅助空间，也不需要对额外空间的操作排序性能较前者更优。其额外辅助空间仅为交换元素时申请的空元素，故额外空间消耗为O(1)。另，堆排序是不稳定排序。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>堆的主要是Shift Up和Shift Down的过程，也写出三个版本的的来理解堆及堆排序，本文代码：<a href="https://gitee.com/Vincent-Vic/DataOrganization/tree/master/MaxHeap" target="_blank" rel="noopener">Heap完整代码</a></p>
<p>有问题欢迎指出！！</p>
<p>小伙伴可以自己实现实现出最小堆的实现</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉堆</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划基础1</title>
    <url>/article/dynamic-base1/</url>
    <content><![CDATA[<h2 id="动态规划入门基础笔记1"><a href="#动态规划入门基础笔记1" class="headerlink" title="动态规划入门基础笔记1"></a>动态规划入门基础笔记1</h2><hr>
<h4 id="什么是动态规划？"><a href="#什么是动态规划？" class="headerlink" title="什么是动态规划？"></a>什么是动态规划？</h4><h5 id="斐波那契数列-Fibonacci-Sequence"><a href="#斐波那契数列-Fibonacci-Sequence" class="headerlink" title="斐波那契数列 Fibonacci Sequence"></a>斐波那契数列 Fibonacci Sequence</h5><p>这个大伙都很熟悉吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过大伙研究过这个的时间复杂度了没，没也没关系，我们现在来看一下斐波那契数列递归的时间性能</p>
<blockquote>
<p>fib(10) = 55 time : 4 e-06 s</p>
<p>fib(20) = 6765 time : 0.000104 s run function fib() 21891 times</p>
<p>fib(40) = 102334155 time : 1.28333 s run function fib() 331160281 times</p>
<p>fib(42) = 267914296 time : 3.47917 s</p>
<p>指数级别的复杂度，O(2^n)</p>
</blockquote>
<p>那把递归树画出来</p>
<p><img src="/" alt="Tree 01" class="lazyload" data-src="/images/dynamic/base20200329/tree01.jpg"></p>
<p>这是一棵fib(5)的计算建立的树图</p>
<p><img src="/" alt="Tree 02" class="lazyload" data-src="/images/dynamic/base20200329/tree02.jpg"></p>
<p>红色区域的是这颗树fib(3)出现的次数，出现了两次</p>
<p><img src="/" alt="Tree 03" class="lazyload" data-src="/images/dynamic/base20200329/tree03.jpg"></p>
<p>蓝色区域的是这颗树fib(2)出现的次数，出现了三次。</p>
<p>这个数据量还是小的,这里可以拿起笔画画或者程序统计一下fib(10)，fib(20),fib(40)的树状图,看看fib(2),fib(3)这种重复执行的次数</p>
<p>相信也能看出来递归的重复执行带来的性能消耗，那么我们可以把这些值存放起来，如果存在就不重复技术。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(n+<span class="number">1</span>, <span class="number">-1</span>)</span></span>;<span class="comment">//记忆数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(memo[n] == <span class="number">-1</span>)  <span class="comment">//如果记忆数组不存在进行计算</span></span><br><span class="line">        memo[n] = fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">	<span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用记忆递归来实现斐波那契，解决重复计算，提高效率，其实这里跟数组实现就很类似</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(n+<span class="number">1</span>, <span class="number">-1</span>)</span></span>; <span class="comment">//记忆数组</span></span><br><span class="line">	nemo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	memo[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        memo[i] = memo[i<span class="number">-1</span>] + memo[i<span class="number">-2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="动态规划-维基百科中的定义"><a href="#动态规划-维基百科中的定义" class="headerlink" title="动态规划 维基百科中的定义"></a><a href="https://zh.wikipedia.org/wiki/动态规划" target="_blank" rel="noopener">动态规划 维基百科</a>中的定义</h5><blockquote>
<p>dynamic programming（also known as dynamic optimization）is a method for solving a complex problem by breaking it down into a collection of simple subproblems，solving each of those subproblems just once，and storing their solutions -ideally，using a memory-based data structure.</p>
<p>将原问题拆解成若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。<br>s</p>
</blockquote>
<p><img src="/" alt="Dynamic" class="lazyload" data-src="/images/dynamic/base20200329/sl.jpg"></p>
<hr>
<p>来看一下</p>
<h2 id="LeetCode-70-爬楼梯"><a href="#LeetCode-70-爬楼梯" class="headerlink" title="LeetCode 70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">LeetCode 70. 爬楼梯</a></h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<h6 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h6><blockquote>
<p>输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
</blockquote>
<h6 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h6><blockquote>
<p>输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
</blockquote>
<h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><p>这题如果采用暴力的解法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">climbStairs(i,n)=(i+<span class="number">1</span>,n)+climbStairs(i+<span class="number">2</span>,n)</span><br></pre></td></tr></table></figure>



<p>在 n = 5 时的递归树将是这样的：</p>
<p><img src="/" alt="暴力求解树" class="lazyload" data-src="/images/dynamic/base20200329/tree04.jpg"></p>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(2^n)，树形递归的大小为 2^n</p>
<p>空间复杂度：O(n)，递归树的深度可以达到n</p>
<h4 id="记忆解法"><a href="#记忆解法" class="headerlink" title="记忆解法"></a>记忆解法</h4><p>那么像上述的多个重复子问题，可以采用记忆递归来实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(memo[n] == <span class="number">-1</span>)  <span class="comment">//如果记忆数组不存在进行计算</span></span><br><span class="line">        memo[n] = climbStairs(i+<span class="number">1</span>,n)+climbStairs(i+<span class="number">2</span>,n)</span><br><span class="line">	<span class="keyword">return</span> memo[n];</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)O(n)，树形递归的大小可以达到 n。</p>
<p>空间复杂度：O(n)O(n)，递归树的深度可以达到 n。</p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>第 i 阶可以由以下两种方法得到：</p>
<blockquote>
<p>在第 (i-1)阶后向上爬 1 阶。<br>在第 (i-2)阶后向上爬 2 阶。</p>
</blockquote>
<p>所以到达第 ii 阶的方法总数就是到第 (i-1) 阶和第 (i-2)阶的方法数之和。</p>
<p>令 dp[i] 表示能到达第 i 阶的方法总数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]</span><br></pre></td></tr></table></figure>

<p>使用迭代的方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>* dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">120. 三角形最小路径和</a></h2><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p>
<p>说明：</p>
<p>如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
<h4 id="解体思路"><a href="#解体思路" class="headerlink" title="解体思路"></a>解体思路</h4><p>题目要求移动到下一行中相邻的结点上，那应该了解一下什么相邻，先看看存储形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2]</span><br><span class="line">[3,4]</span><br><span class="line">[6,5,7]</span><br><span class="line">[4,1,8,3]</span><br></pre></td></tr></table></figure>

<p>不难看出T[0][0]相邻的是T[1][0]和T[1][1]，再举个栗子：T[2][2]相邻的是T[3][2]和T[3][3]</p>
<p>那么就可以得出</p>
<blockquote>
<p>T[i][j]相邻的是T[i+1][j]和T[i+1][j+1]</p>
</blockquote>
<p>//自顶向下</p>
<p><img src="/" alt="三角形最小路径和" class="lazyload" data-src="/images/dynamic/base20200329/path00.gif"></p>
<p>这里需要判断四种情况，上边界（第二行），左右边界和非边界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上边界（第二行）的情况直接对前一行进行累加( i &#x3D;&#x3D; 1 ) ，triangle[i][j] +&#x3D; triangle[0][0];</span><br><span class="line"></span><br><span class="line">左边第一列的情况( j &#x3D;&#x3D; 0)，triangle[i][j] +&#x3D; triangle[i-1][j];</span><br><span class="line"></span><br><span class="line">右边最后一列的情况 ( j &#x3D;&#x3D; i )，triangle[i][j] +&#x3D; triangle[i-1][j-1];</span><br><span class="line"></span><br><span class="line">非边界情况，  triangle[i][j] +&#x3D; min(triangle[i-1][j],triangle[i-1][j-1]);</span><br></pre></td></tr></table></figure>

<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minSum = INT8_MAX;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangle.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( i == <span class="number">1</span> )&#123;  <span class="comment">//第二行的情况直接对前一行进行累加</span></span><br><span class="line">                    triangle[i][j] += triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>( j == <span class="number">0</span>)&#123; <span class="comment">//左边第一列的情况</span></span><br><span class="line">                    triangle[i][j] += triangle[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>( j == i )&#123; <span class="comment">//右边最后一列的情况</span></span><br><span class="line">                    triangle[i][j] += triangle[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123; <span class="comment">//非边界情况</span></span><br><span class="line">                    triangle[i][j] += min(triangle[i<span class="number">-1</span>][j],triangle[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ( i == triangle.size() - <span class="number">1</span>)&#123; <span class="comment">//判断最后一行的情况，查找最小</span></span><br><span class="line">                    minSum = min(minSum,triangle[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>自底向上的思路</p>
<p><img src="/" alt="三角形最小路径和" class="lazyload" data-src="/images/dynamic/base20200329/path01.gif"></p>
<p>从倒数第二行还是计算：dp[i][j] = min(dp[i+1][j],dp[i+j][j+1])+dp[i][j];</p>
<p>自底向上就不用考虑边界问题</p>
<p>代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size() == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//自底向上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = triangle.size()<span class="number">-2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; triangle[i].size();j++ )&#123;</span><br><span class="line">                triangle[i][j] = min(triangle[i+<span class="number">1</span>][j],triangle[i+<span class="number">1</span>][j+<span class="number">1</span>])+triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：O(n^2) （n 为三角形的总行数）</p>
<p>空间复杂度：O(n^2) （n 为三角形的总行数）</p>
<hr>
<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64.最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64.最小路径和</a></h2><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小</span><br></pre></td></tr></table></figure>
<h5 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h5><p>状态定义：</p>
<p>设 dp 为大小 m * n 矩阵，其中设子问题 dp[i][j] 的值代表直到走到 (i,j) 的最小路径和。</p>
<blockquote>
<p>题目要求，每次只能向下或者向右移动一步,反过来想，当前单元格 (i,j) 只能从左方单元格 (i-1,j) 或上方单元格 (i,j-1)走到，因此只需要考虑矩阵左边界和上边界。</p>
</blockquote>
<p>遍历矩阵，把可能走到当前(i,j)的坐标进行比较，最小值累加到当前(i,j)，这样就能得到到达子问题最短路径，目前需要考虑的边界问题</p>
<p>四种情况：起点、上边界、左边界、非边界</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">起 点： 当前节点既是上边界也是左边界(i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)时，  grid[i][j] &#x3D; grid[i][j];</span><br><span class="line">上边界：当只是上边界时(i &#x3D;&#x3D;0 &amp;&amp; j ！&#x3D; 0) , grid[i][j] &#x3D; grid[i][j-1] + grid[i][j];</span><br><span class="line">左边界：当是左边界但不是上边界时(i !&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)，grid[i][j] &#x3D; grid[i-1][j] + grid[i][j];</span><br><span class="line">非边界：当不是边界(i !&#x3D; 0 &amp;&amp; j !&#x3D; 0),grid[i][j] &#x3D; min(grid[i-1][j],grid[i][j-1]) + grid[i][j];</span><br></pre></td></tr></table></figure>

<p><img src="/" alt="最小路径和" class="lazyload" data-src="/images/dynamic/base20200329/path02.gif"></p>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度O(M×N) ： 遍历整个 grid矩阵元素。<br>空间复杂度 O(1)： 直接修改原矩阵，不使用额外空间。</p>
<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123; <span class="comment">//起点情况</span></span><br><span class="line">                    grid[i][j] = grid[i][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)&#123; <span class="comment">//上边界情况</span></span><br><span class="line">                    grid[i][j] = grid[i][j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123; <span class="comment">//左边界情况（不在上边界的情况）</span></span><br><span class="line">                    grid[i][j] = grid[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>)&#123; <span class="comment">//非边界</span></span><br><span class="line">                    grid[i][j] = min(grid[i<span class="number">-1</span>][j],grid[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.size()<span class="number">-1</span>][grid[<span class="number">0</span>].size()<span class="number">-1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>未完待续</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径和</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket学习笔记之入门1</title>
    <url>/article/socket-xue-xi-bi-ji-zhi-ru-men-1/</url>
    <content><![CDATA[<p>一个简单的SocketDemo快速入门</p>
<h3 id="什么是计算机网络，网络是怎么构成的？"><a href="#什么是计算机网络，网络是怎么构成的？" class="headerlink" title="什么是计算机网络，网络是怎么构成的？"></a>什么是计算机网络，网络是怎么构成的？</h3><p><img src="/" alt="网络" class="lazyload" data-src="/images/socket/dome20200323/1.png"></p>
<p>在计算机领域中，网络是信息传输，接收，共享的虚拟平台</p>
<p>通过它把各个点，面，体的信息联系到一起，从而实现这些资源的共享</p>
<p>网络是人类发展史以来非常重要的发明，提高了科技和人类社会的发展</p>
<h3 id="什么是网络编程"><a href="#什么是网络编程" class="headerlink" title="什么是网络编程"></a>什么是网络编程</h3><p>网络编程从大的方面说就是对信息的发生到接收</p>
<p>通过操作相应API调度计算机资源，并利用传输通道(无线/网线)进行数据交换的过程</p>
<p>具体涉及：网络模型，套接字，数据包</p>
<h3 id="简单了解Socket"><a href="#简单了解Socket" class="headerlink" title="简单了解Socket"></a>简单了解Socket</h3><h5 id="Socket概述"><a href="#Socket概述" class="headerlink" title="Socket概述"></a>Socket概述</h5><blockquote>
<p>Socket是TCP/IP协议的编程模型，是提供两台计算机通信的网络编程接口，主要通过TCP/IP协议中的传输层的TCP,UDP协议的操作实体</p>
</blockquote>
<h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><hr>
<blockquote>
<p>TCP（Transmission Control Protocol，传输控制协议）:面向连接的传输</p>
<p>UDP（User Datagram Protocol，用户数据包协议）:面向连接</p>
<p>简而言之，TCP是需要确认消息的传输，而UDP是只管发送，不需要存在连接</p>
<p>IP （网络之间互连的协议）：主要区分局域网IP和公网IP</p>
<p>Prot (端口)：用于区分计算机服务的一个访问手段</p>
</blockquote>
<hr>
<h3 id="Soket-Demo分解"><a href="#Soket-Demo分解" class="headerlink" title="Soket Demo分解"></a>Soket Demo分解</h3><h5 id="C-S模式"><a href="#C-S模式" class="headerlink" title="C/S模式"></a>C/S模式</h5><p><img src="/" alt="C/S" class="lazyload" data-src="/images/socket/dome20200323/base0.png"></p>
<blockquote>
<p>在TCP/IP网络应用中，通信的两个进程间相互作用的主要模式是客户/服务器（Client/Server, C/S）模式，即客户向服务器发出服务请求，服务器接收到请求后，提供相应的服务。</p>
</blockquote>
<p><img src="/" alt="C/S" class="lazyload" data-src="/images/socket/dome20200323/base.png"></p>
<p>通过Socket建立一个简单的客户端与服务端的通信。</p>
<hr>
<h5 id="服务端的建立"><a href="#服务端的建立" class="headerlink" title="服务端的建立"></a>服务端的建立</h5><blockquote>
<p>ps：本文采用Java作为例子，本文以TCP协议作为第一个Demo的小例子</p>
</blockquote>
<p>我们需要创建服务端</p>
<p>Java提供了服务端的ServerSocket这个类，我们可以通过这个类去实现服务端的建立</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(Prot); <span class="comment">//建立绑定端口</span></span><br></pre></td></tr></table></figure>

<p>建立完就是开始监听客户端的消息</p>
<p>使用ServerSocket中的accept()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket client = serverSocket.accept();<span class="comment">//等待客户端连接</span></span><br></pre></td></tr></table></figure>

<hr>
<p><img src="/" alt="监听处理" class="lazyload" data-src="/images/socket/dome20200323/accept.png"></p>
<p>监听会一直等待到客户端的连接，当连接成功就进行下一步的消息处理</p>
<p>消息监听处理代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//循环监听</span></span><br><span class="line">        System.out.println(<span class="string">"监听"</span>);</span><br><span class="line">        <span class="comment">//等待客户端连接</span></span><br><span class="line">        Socket client = serverSocket.accept();</span><br><span class="line">        <span class="comment">//发送到客户端 </span></span><br><span class="line">        <span class="comment">//TODO 后续解说，这里体现监听处理操作</span></span><br><span class="line">        <span class="comment">//从客户端接收一行</span></span><br><span class="line">        <span class="comment">//TODO 后续解说，这里体现监听处理操作</span></span><br><span class="line">        System.out.println(<span class="string">"客户端消息：xxxx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="/" alt="通信过程过程" class="lazyload" data-src="/images/socket/dome20200323/accept2.gif"></p>
<p>如图客户1连接正在通信，此时一个新的用户的请求连接服务端未能及时响应，一直等待服务端的接收，直到客户1断开连接，服务端重新监听，才接收了客户2的连接，意味着上一个客户端连接如果没有断开，会一直占用服务端的处理</p>
<hr>
<p><img src="/" alt="多线程处理" class="lazyload" data-src="/images/socket/dome20200323/accept3.gif"></p>
<p>本图为了实现多个客户端，我们一般通过开一个线程的方式去处理用户连接后的消息，服务端主要复制接收连接和创建线程去处理消息，这样就不会多客户的需要频繁等待，像上一个客户如果一直未响应就影响后续的客户的操作。</p>
<p>多线程创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里采用嵌套静态子类，也可以单独创建一个外部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            System.out.println(<span class="string">"新客户端连接-ip:"</span>+socket.getLocalAddress()+<span class="string">"/Port:"</span>+socket.getPort());</span><br><span class="line">            handleMsg(); <span class="comment">//自定义处理消息函数，见后文</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="客户端建立"><a href="#客户端建立" class="headerlink" title="客户端建立"></a>客户端建立</h5><p>创建客户端Socket对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket socket = <span class="keyword">new</span> Socket();</span><br></pre></td></tr></table></figure>

<p>建立服务器连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置超时时间</span></span><br><span class="line">socket.setSoTimeout(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//连接本地服务器，端口怕0000，超时3000ms</span></span><br><span class="line">socket.connect(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getLocalHost(),Prot),<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>InetSocketAddress</p>
<blockquote>
<p>该类实现了可序列化接口，直接继承自java.net.SocketAddress类，类声明如下： public class InetSocketAddress extends SocketAddress</p>
</blockquote>
<p>Inet4Address.getLocalHost()</p>
<blockquote>
<p>获取本地地址</p>
</blockquote>
<hr>
<h5 id="Socket通信"><a href="#Socket通信" class="headerlink" title="Socket通信"></a>Socket通信</h5><p>已经建立好了连接，那接下来就是客户端与服务端的通信过程</p>
<p>我这里封装发送和接受消息的两个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoketInputUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader soketReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoketInputUtil</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        inputStream = socket.getInputStream();</span><br><span class="line">        soketReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readMag</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//从服务器接收一行</span></span><br><span class="line">        <span class="keyword">return</span> soketReader.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;<span class="comment">//关闭资源 TODO    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoketOutputUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> PrintStream soketPrintStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoketOutputUtil</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        outputStream = socket.getOutputStream();</span><br><span class="line">        soketPrintStream = <span class="keyword">new</span> PrintStream(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">sendMsg</span><span class="params">(String info)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//发送到服务器</span></span><br><span class="line">        soketPrintStream.println(info);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123; <span class="comment">//关闭资源 TODO &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端和客户端处理消息的逻辑大致一致，为了方便简洁我这里写成函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理消息函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Boolean <span class="title">handleMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            SoketOutputUtil soketOutput = <span class="keyword">null</span>;</span><br><span class="line">            SoketInputUtil soketInput = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//客户端消息代码可以从这个代码修改</span></span><br><span class="line">                <span class="comment">//=================================</span></span><br><span class="line">                    <span class="comment">//发送到客户端</span></span><br><span class="line">                    soketOutput = <span class="keyword">new</span> SoketOutputUtil(socket);</span><br><span class="line">                    soketOutput.sendMsg(<span class="string">"hello www.iflags.cn"</span>);</span><br><span class="line">                    <span class="comment">//从客户端接收一行</span></span><br><span class="line">                    soketInput = <span class="keyword">new</span> SoketInputUtil(socket);</span><br><span class="line">                    String echo = soketInput.readMag();</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//判断服务器是否断开连接</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"bye"</span>.equalsIgnoreCase(echo)) &#123;</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//打印服务器发送的信息</span></span><br><span class="line">                        System.out.println(echo);</span><br><span class="line">                        soketOutput.sendMsg(<span class="string">"回送:"</span>+echo.length());</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//=================================</span></span><br><span class="line">                &#125;<span class="keyword">while</span> (<span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                soketInput.close();</span><br><span class="line">                soketOutput.close();</span><br><span class="line">                System.out.println(<span class="string">"断开连接"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发送</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>补充服务端监听代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//循环监听</span></span><br><span class="line">    System.out.println(<span class="string">"监听"</span>);</span><br><span class="line">    <span class="comment">//等待客户端连接</span></span><br><span class="line">    Socket client = serverSocket.accept();</span><br><span class="line">    <span class="comment">//加入多线程</span></span><br><span class="line">    ClientHandler clientHandler = <span class="keyword">new</span> ClientHandler(client);</span><br><span class="line">    clientHandler.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本文包含一些个人简单的封装逻辑，菜鸡写的小demo，可能存在一些问题完整代码可以访问连接查看：<a href="https://gitee.com/Vincent-Vic/SocketLearn/tree/master/src/main/java/cn/vic/soket/demo1" target="_blank" rel="noopener">SocketBaseDemo1</a>,<a href="https://gitee.com/Vincent-Vic/SocketLearn/tree/master/src/main/java/cn/vic/soket" target="_blank" rel="noopener">简单封装的Util</a></p>
]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Socket</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket学习笔记之入门2 UDP</title>
    <url>/article/socket-xue-xi-bi-ji-zhi-ru-men-2/</url>
    <content><![CDATA[<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><blockquote>
<p>UDP（User Datagram Protocol），用户数据报协议，是OSI(Open System Interconnection，开放式系统互联) 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP提供了无连接通信，且不对传送数据包进行可靠性保证，适合于一次传输少量数据，UDP传输的可靠性由应用层负责。</p>
<p>UDP报文没有可靠性保证、顺序保证和流量控制字段等，可靠性较差。但是正因为UDP协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。</p>
</blockquote>
<p>报文结构</p>
<p><img src="/" alt="UDP" class="lazyload" data-src="/images/socket/dome20200411/1.png"></p>
<p>UDP最大长度</p>
<p>16位 -&gt; 2字节 存储长度信息</p>
<p>2^16-1 = 64k - 1 = 64-1 = 65536 - 1 = 65535</p>
<p>自身协议占用：32+32位 = 64位 = 8字节</p>
<p>65535-8 = 65507 byte</p>
<h3 id="UDP-主要API"><a href="#UDP-主要API" class="headerlink" title="UDP 主要API"></a>UDP 主要API</h3><h4 id="API-DatagramSocket"><a href="#API-DatagramSocket" class="headerlink" title="API-DatagramSocket"></a>API-DatagramSocket</h4><p>用于接收与发送UDP 的类</p>
<p>负责发送或者接收UDP包</p>
<p>UDP不在Socket API中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DatagramSocket()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建简单实例，不指定端口与IP</span><br><span class="line"></span><br><span class="line">DatagramSocket(int port)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建监听固定端口单实例</span><br><span class="line"></span><br><span class="line">DatagramSocket(int port,InetAddress localAddress)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建固定端口指定IP</span><br><span class="line"></span><br><span class="line">receive(DatagramPacket d) &#x2F;&#x2F;接收</span><br><span class="line"></span><br><span class="line">send(DatagramPacket d) &#x2F;&#x2F;发送</span><br><span class="line"></span><br><span class="line">setSoTimeout(int timeout) &#x2F;&#x2F;设置超时时间</span><br><span class="line"></span><br><span class="line">close() &#x2F;&#x2F;关闭，释放资源</span><br></pre></td></tr></table></figure>


<h4 id="API-DatagramPacket"><a href="#API-DatagramPacket" class="headerlink" title="API-DatagramPacket"></a>API-DatagramPacket</h4><p>用于处理报文</p>
<p>将byte数组，目标地址，目标端口等数据保证成报文或者将报文拆解成byte数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//              数据        起始区间   长度      目标地址           目标端口</span></span><br><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf,<span class="keyword">int</span> offset,<span class="keyword">int</span> length,InetAddress address,<span class="keyword">int</span> port)</span><br><span class="line"></span><br><span class="line"><span class="comment">//              数据        起始区间   长度      目标地址+端口           </span></span><br><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf,<span class="keyword">int</span> offset,<span class="keyword">int</span> length,SocketAddress address)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置数据</span></span><br><span class="line">setData(<span class="keyword">byte</span>[] buf,<span class="keyword">int</span> offset,<span class="keyword">int</span> length)</span><br><span class="line">setData(<span class="keyword">byte</span>[] buf) <span class="comment">//默认全部</span></span><br><span class="line">setLength(<span class="keyword">int</span> length) <span class="comment">//设置长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line">getData()、getOffset()、getLength()</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置地址和端口</span></span><br><span class="line">setAddress(InetAddress iaddr)</span><br><span class="line">setPort(<span class="keyword">int</span> iport)</span><br><span class="line">setSocketAddress(SocketAddress address)</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到地址和端口</span></span><br><span class="line">getAddress()</span><br><span class="line">getPort()</span><br><span class="line">getSocketAddress()</span><br></pre></td></tr></table></figure>

<h3 id="单播-广播-多播"><a href="#单播-广播-多播" class="headerlink" title="单播/广播/多播"></a>单播/广播/多播</h3><p><img src="/" alt="单播/广播/多播" class="lazyload" data-src="/images/socket/dome20200411/2.png"></p>
<h4 id="IP网段"><a href="#IP网段" class="headerlink" title="IP网段"></a>IP网段</h4><p><img src="/" alt="IP网段" class="lazyload" data-src="/images/socket/dome20200411/3.png"></p>
<h4 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h4><p>255.255.255.255 受限广播地址</p>
<p>C网广播地址一般为：xxx.xxx.xxx.255 (192.168.1.255)</p>
<h3 id="UDP简单例子"><a href="#UDP简单例子" class="headerlink" title="UDP简单例子"></a>UDP简单例子</h3><p>接收者端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPProviderDome</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UDPProviderDome Started."</span>);</span><br><span class="line">        <span class="comment">//指定接口接收 指定一个端口接收</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println("ip:"+ds.getInetAddress().getHostAddress()+"--port:"+ds.getPort());</span></span><br><span class="line">        <span class="comment">//创建接收实体</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">        DatagramPacket receivePack = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收</span></span><br><span class="line">        ds.receive(receivePack);</span><br><span class="line">        System.out.println(<span class="string">"UDPProviderDome receive."</span>);</span><br><span class="line">        <span class="comment">//打印接收地址与发送者信息</span></span><br><span class="line">        String ip = receivePack.getAddress().getHostAddress();</span><br><span class="line">        <span class="keyword">int</span> port = receivePack.getPort();</span><br><span class="line">        <span class="keyword">int</span> dataLen = receivePack.getLength();</span><br><span class="line">        String data = <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, dataLen);</span><br><span class="line">        System.out.println(<span class="string">"ip:"</span> + ip + <span class="string">"- port:"</span> + port + <span class="string">"--data:"</span> + data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回送数据</span></span><br><span class="line">        String responseData = <span class="string">"Receive data with:"</span> + dataLen;</span><br><span class="line">        <span class="keyword">byte</span>[] responseDataBytes = responseData.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接根据发送者回送信息</span></span><br><span class="line">        DatagramPacket responsePacket = <span class="keyword">new</span> DatagramPacket(responseDataBytes, responseDataBytes.length,</span><br><span class="line">                receivePack.getAddress(), receivePack.getPort());</span><br><span class="line">        ds.send(responsePacket);</span><br><span class="line">        System.out.println(<span class="string">"UDPProviderDome Send."</span>);</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索者端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSearcherDome</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UDPSearcherDome Started."</span>);</span><br><span class="line">        <span class="comment">//搜索方系统自动分配端口</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发生数据</span></span><br><span class="line">        String responseData = <span class="string">" Hello World"</span> ;</span><br><span class="line">        <span class="keyword">byte</span>[] responseDataBytes = responseData.getBytes();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建</span></span><br><span class="line">        DatagramPacket sendPacket = <span class="keyword">new</span> DatagramPacket(responseDataBytes, responseDataBytes.length);</span><br><span class="line">        <span class="comment">//本金20000端口</span></span><br><span class="line">        sendPacket.setAddress(InetAddress.getLoopbackAddress());</span><br><span class="line">        sendPacket.setPort(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送</span></span><br><span class="line">        ds.send(sendPacket);</span><br><span class="line">        System.out.println(<span class="string">"UDPSearcherDome Send."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建接收实体</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">        DatagramPacket receivePack = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收</span></span><br><span class="line">        ds.receive(receivePack);</span><br><span class="line">        System.out.println(<span class="string">"UDPSearcherDome receive."</span>);</span><br><span class="line">        <span class="comment">//打印接收地址与发送者信息</span></span><br><span class="line">        String ip = receivePack.getAddress().getHostAddress();</span><br><span class="line">        <span class="keyword">int</span> port = receivePack.getPort();</span><br><span class="line">        <span class="keyword">int</span> dataLen = receivePack.getLength();</span><br><span class="line">        String data = <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, dataLen);</span><br><span class="line">        System.out.println(<span class="string">"ip:"</span> + ip + <span class="string">"- port:"</span> + port + <span class="string">"--data:"</span> + data);</span><br><span class="line"></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广播例子"><a href="#广播例子" class="headerlink" title="广播例子"></a>广播例子</h3><p>描述：提供者监听接收信息，搜索者提供广播发送消息，提供广播者发来信息的端口提供者回复消息，本例子中，需要多台不同网络的设备运行测试比较容易理解过程</p>
<p>提供者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPProviderDome</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String sn = UUID.randomUUID().toString();</span><br><span class="line">        Provider provider = <span class="keyword">new</span> Provider(sn);</span><br><span class="line">        provider.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取任意字符退出</span></span><br><span class="line">        System.in.read();</span><br><span class="line">        provider.exit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String sn;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">private</span> DatagramSocket ds = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Provider</span><span class="params">(String sn)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.sn = sn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            System.out.println(<span class="string">"UDPProviderDome Started."</span>);</span><br><span class="line">            <span class="comment">//指定接口接收 指定一个端口接收</span></span><br><span class="line">            DatagramSocket ds = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ds = <span class="keyword">new</span> DatagramSocket(<span class="number">20000</span>);</span><br><span class="line">                <span class="keyword">while</span> (!done) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//System.out.println("ip:"+ds.getInetAddress().getHostAddress()+"--port:"+ds.getPort());</span></span><br><span class="line">                    <span class="comment">//创建接收实体</span></span><br><span class="line">                    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line">                    DatagramPacket receivePack = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//接收</span></span><br><span class="line">                    ds.receive(receivePack);</span><br><span class="line">                    System.out.println(<span class="string">"UDPProviderDome receive."</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//打印接收地址与发送者信息</span></span><br><span class="line">                    String ip = receivePack.getAddress().getHostAddress();</span><br><span class="line">                    <span class="keyword">int</span> port = receivePack.getPort();</span><br><span class="line">                    <span class="keyword">int</span> dataLen = receivePack.getLength();</span><br><span class="line">                    String data = <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, dataLen);</span><br><span class="line">                    System.out.println(<span class="string">"ip:"</span> + ip + <span class="string">"- port:"</span> + port + <span class="string">"--data:"</span> + data);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> responsePort = MessageCreator.parsePort(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (responsePort != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//回送数据</span></span><br><span class="line">                        String responseData = MessageCreator.buildWithSn(sn);</span><br><span class="line">                        <span class="keyword">byte</span>[] responseDataBytes = responseData.getBytes();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//直接根据发送者回送信息</span></span><br><span class="line">                        DatagramPacket responsePacket = <span class="keyword">new</span> DatagramPacket(responseDataBytes, responseDataBytes.length,</span><br><span class="line">                                receivePack.getAddress(), responsePort);</span><br><span class="line">                        ds.send(responsePacket);</span><br><span class="line">                        System.out.println(<span class="string">"UDPProviderDome Send."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ds != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ds.close();</span><br><span class="line">                ds = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span></span>&#123;</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package cn.vic.soket.demo2;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 描述:搜索者</span><br><span class="line"> * @author Vincent Vic</span><br><span class="line"> * create 2020-03-22 16:06</span><br><span class="line"> *&#x2F;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.DatagramPacket;</span><br><span class="line">import java.net.DatagramSocket;</span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line">public class UDPSearcherDome &#123;</span><br><span class="line">    private static final int LISTEN_PORT &#x3D; 30000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;UDPSearcherDome Started.&quot;);</span><br><span class="line"></span><br><span class="line">        Listener listener &#x3D; listen();</span><br><span class="line">        sendBroadcast();</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">        List&lt;Device&gt; devices &#x3D; listener.getDevicesAndClose();</span><br><span class="line"></span><br><span class="line">        for (Device device : devices)&#123;</span><br><span class="line">            System.out.println(&quot;Device:&quot;+device.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Listener listen() throws InterruptedException &#123;</span><br><span class="line">        System.out.println(&quot;Listener&quot;);</span><br><span class="line">        CountDownLatch downLatch &#x3D; new CountDownLatch(1);</span><br><span class="line">        Listener listener &#x3D; new Listener(LISTEN_PORT, downLatch);</span><br><span class="line">        listener.start();</span><br><span class="line"></span><br><span class="line">        downLatch.await();</span><br><span class="line">        return listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void sendBroadcast() throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;UDPSearcherDome Broadcast Started.&quot;);</span><br><span class="line">        &#x2F;&#x2F;搜索方系统自动分配端口</span><br><span class="line">        DatagramSocket ds &#x3D; new DatagramSocket();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发生数据</span><br><span class="line">        String responseData &#x3D; MessageCreator.buildWithPort(LISTEN_PORT) ;</span><br><span class="line">        byte[] responseDataBytes &#x3D; responseData.getBytes();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;构建</span><br><span class="line">        DatagramPacket sendPacket &#x3D; new DatagramPacket(responseDataBytes, responseDataBytes.length);</span><br><span class="line">        &#x2F;&#x2F;本金20000端口</span><br><span class="line">        sendPacket.setAddress(InetAddress.getByName(&quot;255.255.255.255&quot;));</span><br><span class="line">        sendPacket.setPort(20000);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;发送</span><br><span class="line">        ds.send(sendPacket);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;完成</span><br><span class="line">        System.out.println(&quot;UDPSearcherDome Broadcast Finished.&quot;);</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;设备</span><br><span class="line">    private static class Device&#123;</span><br><span class="line">        final int port;</span><br><span class="line">        final String ip;</span><br><span class="line">        final String sn;</span><br><span class="line"></span><br><span class="line">        public Device(int port, String ip, String sn) &#123;</span><br><span class="line">            this.port &#x3D; port;</span><br><span class="line">            this.ip &#x3D; ip;</span><br><span class="line">            this.sn &#x3D; sn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;Device&#123;&quot; +</span><br><span class="line">                    &quot;port&#x3D;&quot; + port +</span><br><span class="line">                    &quot;, ip&#x3D;&#39;&quot; + ip + &#39;\&#39;&#39; +</span><br><span class="line">                    &quot;, sn&#x3D;&#39;&quot; + sn + &#39;\&#39;&#39; +</span><br><span class="line">                    &#39;&#125;&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private static class Listener extends Thread&#123;</span><br><span class="line">        private final int listenPort;</span><br><span class="line">        private final CountDownLatch countDownLatch;</span><br><span class="line">        private final List&lt;Device&gt; devices &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        private boolean done &#x3D; false;</span><br><span class="line">        private DatagramSocket ds &#x3D; null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        public Listener(int listenPort, CountDownLatch countDownLatch) &#123;</span><br><span class="line">            this.listenPort &#x3D; listenPort;</span><br><span class="line">            this.countDownLatch &#x3D; countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            super.run();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;通知启动</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;监听回收端口</span><br><span class="line">                ds &#x3D; new DatagramSocket(listenPort);</span><br><span class="line"></span><br><span class="line">                while (!done)&#123;</span><br><span class="line">                    System.out.println(&quot;UDPSearcherDome Listener Started.&quot;);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;创建接收实体</span><br><span class="line">                    final byte[] buf &#x3D; new byte[512];</span><br><span class="line">                    DatagramPacket receivePack &#x3D; new DatagramPacket(buf, buf.length);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;接收</span><br><span class="line">                    ds.receive(receivePack);</span><br><span class="line">                    System.out.println(&quot;UDPSearcherDome receive.&quot;);</span><br><span class="line">                    &#x2F;&#x2F;打印接收地址与发送者信息</span><br><span class="line">                    String ip &#x3D; receivePack.getAddress().getHostAddress();</span><br><span class="line">                    int port &#x3D; receivePack.getPort();</span><br><span class="line">                    int dataLen &#x3D; receivePack.getLength();</span><br><span class="line">                    String data &#x3D; new String(receivePack.getData(), 0, dataLen);</span><br><span class="line">                    System.out.println(&quot;ip:&quot; + ip + &quot;- port:&quot; + port + &quot;--data:&quot; + data);</span><br><span class="line"></span><br><span class="line">                    String sn &#x3D; MessageCreator.parseSn(data);</span><br><span class="line">                    if (sn !&#x3D; null)&#123;</span><br><span class="line">                        Device device &#x3D; new Device(port,ip,sn);</span><br><span class="line">                        devices.add(device);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; catch (Exception e)&#123;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public List&lt;Device&gt; getDevicesAndClose() &#123;</span><br><span class="line">            done &#x3D; true ;</span><br><span class="line">            ds.close();</span><br><span class="line">            return devices;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void close()&#123;</span><br><span class="line">            if (ds !&#x3D; null)&#123;</span><br><span class="line">                ds.close();</span><br><span class="line">                ds &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void exit()&#123;</span><br><span class="line">            done &#x3D; true;</span><br><span class="line">            close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>例子中所用的信息创建，用于加入口令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MessageCreator &#123;</span><br><span class="line">    private static final String SN_HEADER &#x3D; &quot;收到暗号，我是（SN）:&quot;;</span><br><span class="line">    private static final String PORT_HEADER &#x3D; &quot;这是暗号，请回电端口（Port）&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建信息</span><br><span class="line">    public static String buildWithPort(int port)&#123;</span><br><span class="line">        return PORT_HEADER + port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;解析信息</span><br><span class="line">    public static int parsePort(String data)&#123;</span><br><span class="line">        if (data.startsWith(PORT_HEADER))&#123;</span><br><span class="line">            return Integer.parseInt(data.substring(PORT_HEADER.length()));</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建暗号</span><br><span class="line">    public static String buildWithSn(String sn)&#123;</span><br><span class="line">        return SN_HEADER+sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String parseSn(String data)&#123;</span><br><span class="line">        if (data.startsWith(SN_HEADER))&#123;</span><br><span class="line">            return data.substring(SN_HEADER.length());</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Socket</category>
      </categories>
      <tags>
        <tag>Socket</tag>
        <tag>网络编程</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索树</title>
    <url>/article/binarysearchtree/</url>
    <content><![CDATA[<p>Binary Search Tree</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><img src="/" alt="tree" class="lazyload" data-src="/images/BST/tree20200320/tree0.jpg"></p>
<blockquote>
<p> 二分搜索树是在二叉树结构上实现的一种数据结构；搜索树主要是用来实现快速查找的字典结构，结构主要特点，左小右大。 </p>
</blockquote>
<p>本文主要以图片和代码实现来探讨一个最简单的二叉搜索树（C++版）</p>
<h3 id="功能概况"><a href="#功能概况" class="headerlink" title="功能概况"></a>功能概况</h3><p>类的定义,也分别介绍这些基础算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key,<span class="keyword">typename</span> Value&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>    <span class="comment">//节点结构体</span></span><br><span class="line">        Key key;Value value;Node* left; Node* right;</span><br><span class="line">        Node(Key key,Value value);</span><br><span class="line">        Node(Node* node);<span class="comment">//拷贝函数</span></span><br><span class="line">    &#125;;</span><br><span class="line">    Node * root; <span class="comment">//树根</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key,Value value)</span></span>;<span class="comment">//插入</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(Key key)</span></span>;<span class="comment">//判断键值是否存在</span></span><br><span class="line">    <span class="function">Value* <span class="title">search</span><span class="params">(Key key)</span></span>;<span class="comment">//查找</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;<span class="comment">//深度优先遍历(DFS) 先序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;<span class="comment">//深度优先遍历(DFS) 中序遍历 有序遍历二分搜索树</span></span><br><span class="line">    <span class="comment">//深度优先遍历(DFS) 后续遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>;<span class="comment">//广度优先遍历(BFS) 层次遍历-队列实现</span></span><br><span class="line">    <span class="function">Key <span class="title">maximum</span><span class="params">()</span></span>;<span class="comment">//查找最大值</span></span><br><span class="line">    <span class="function">Key <span class="title">minimum</span><span class="params">()</span></span>;<span class="comment">//查找最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMin</span><span class="params">()</span></span>; <span class="comment">//删除最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span></span>; <span class="comment">//删除最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Key key)</span></span>;<span class="comment">//删除节点  Hubbard Deletion思想</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(Node* node)</span></span>;<span class="comment">//销毁树 后序遍历的应用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="搜索树的插入及修改"><a href="#搜索树的插入及修改" class="headerlink" title="搜索树的插入及修改"></a>搜索树的插入及修改</h3><p><img src="/" alt="insert" class="lazyload" data-src="/images/BST/tree20200320/tree1.gif"></p>
<blockquote>
<p>那我们看插入结构的的动态图，小插左子树中，大插右子树中，最好实现思路就是递归策略</p>
</blockquote>
<blockquote>
<p>修改于插入一样的方法，本版本中不支持key相同，已存在的Key值作为修改操作</p>
</blockquote>
<blockquote>
<p>插入的代码实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入的调用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        root = insert(root,key,value);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以node为根递归插入</span></span><br><span class="line"><span class="comment">     * 形成左小右大的二分搜索树逻辑</span></span><br><span class="line"><span class="comment">     * @return 新的节点或者修改的点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* node , Key key , Value value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>)&#123;  <span class="comment">//递归结束条件：当前节点为空，将节点插</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value); <span class="comment">//创建新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span>( key == node-&gt;key)  <span class="comment">//如果key已经存在，替换key旧的值value</span></span><br><span class="line">             node-&gt;value = value;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; node-&gt;key) <span class="comment">//key小于当前节点key 从左子树递归插入</span></span><br><span class="line">             node-&gt;left = insert(node-&gt;left,key,value);</span><br><span class="line">         <span class="keyword">else</span>   <span class="comment">//此时key大于当前节点key，向右子树递归插入</span></span><br><span class="line">             node-&gt;right = insert(node-&gt;right,key,value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这当中的Key是存放在树中节点的位置的关键和Value则是key对应的数据，实现通过key去获取value，本文Key,Value是模板参数，可以根据用户指定数据类型</p>
</blockquote>
<blockquote>
<p>本文代码实现对用户隐藏具体实现，像这样的用户调用接口，下文只出现具体实现，不过多赘述</p>
</blockquote>
<hr>
<h3 id="搜索树的查找"><a href="#搜索树的查找" class="headerlink" title="搜索树的查找"></a>搜索树的查找</h3><blockquote>
<p>关于树的查找，这里先来分析的一下怎么找到一个树的最大值最小值</p>
</blockquote>
<p><img src="/" alt="search" class="lazyload" data-src="/images/BST/tree20200320/tree2.gif"></p>
<blockquote>
<p>再谈树的定义，左节点比根节点小，右节点比根节点小，可以把这看成一个子问题；那最小值不就在左子树里面的左子树的左节点，这一句话似乎有点递归，如果这有点绕，那看图可以知道最左边的那个节点就是最小值</p>
</blockquote>
<p><img src="/" alt="search" class="lazyload" data-src="/images/BST/tree20200320/tree3.gif"></p>
<blockquote>
<p>那么左子树的左节点不存在呢，那么看图很明显就看得出来是最左边的根节点，右子树也同理</p>
</blockquote>
<blockquote>
<p>查找最大值/最小值代码实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以node为根的二叉树 查找最大值</span></span><br><span class="line"><span class="function">Node* <span class="title">maximum</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span>)    <span class="comment">//如果右节点不存在，当前节点即最大</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">return</span> maximum(node-&gt;right); <span class="comment">//存在右节点继续递归查找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以node为根的二叉树 查找最小值</span></span><br><span class="line"><span class="function">Node* <span class="title">minimum</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>) <span class="comment">//如果左节点不存在，当前节点即最小</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    <span class="keyword">return</span> minimum(node-&gt;left); <span class="comment">//存在左节点继续递归查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>那我们再来看查找一个节点的逻辑，这里实现contain和search均属于查找基本的思路</p>
</blockquote>
<p><img src="/" alt="preOrder" class="lazyload" data-src="/images/BST/tree20200320/tree4.gif"></p>
<blockquote>
<p>二分查找的思路还是很简单的，数组的二分查找使用折半法，这里通过左子树，右子树对半的思路</p>
</blockquote>
<blockquote>
<p>查找一个节点的代码实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以node为根的二叉树中判断树中是否包含键值key的节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(Node* node,Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (key == node-&gt;key)   <span class="comment">//如果键值与当前相等说明存在返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; node-&gt;key) <span class="comment">//key 小于当前节点key 从左子树递归查找判断key是否存在</span></span><br><span class="line">        <span class="keyword">return</span> contain(node-&gt;left,key);</span><br><span class="line">    <span class="keyword">else</span>   <span class="comment">//此时key大于当前节点key，向右子树递归查找判断key是否存在</span></span><br><span class="line">        <span class="keyword">return</span> contain(node-&gt;right,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以node为根的二叉树中查找节点  @return value地址</span></span><br><span class="line"><span class="function">Value* <span class="title">search</span><span class="params">(Node* node,Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( key == node-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> &amp;(node-&gt;value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; node-&gt;key) <span class="comment">//key 小于当前节点key 从左子树递归查找判断key是否存在</span></span><br><span class="line">        <span class="keyword">return</span> search(node-&gt;left,key);</span><br><span class="line">    <span class="keyword">else</span>   <span class="comment">//此时key大于当前节点key，向右子树递归查找判断key是否存在</span></span><br><span class="line">        <span class="keyword">return</span> search(node-&gt;right,key);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>contain实现判断key是否存在，search查找返回Value值，两者实现除了返回结果不一致，思路实现一模一样，本文二分搜索树以递归实现</p>
</blockquote>
<hr>
<h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><p><img src="/" alt="preOrder" class="lazyload" data-src="/images/BST/tree20200320/tree5.gif"></p>
<blockquote>
<p>先序遍历：对任一子树，先访问根，然后遍历其左子树，最后遍历其右子树。(巧记根左右)</p>
</blockquote>
<p><img src="/" alt="inOrder" class="lazyload" data-src="/images/BST/tree20200320/tree6.gif"></p>
<blockquote>
<p>中序遍历：对任一子树，先遍历其左子树，然后访问根，最后遍历其右子树。(巧记左根右)</p>
</blockquote>
<p><img src="/" alt="postOrder" class="lazyload" data-src="/images/BST/tree20200320/tree7.gif"></p>
<blockquote>
<p>后序遍历：对任一子树，先遍历其左子树，然后遍历其右子树，最后访问根。(巧记左右根)</p>
</blockquote>
<blockquote>
<p>深度优先遍历实现代码</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以node为根的二叉树 进行先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;node-&gt;key &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        preOrder(node-&gt;left);</span><br><span class="line">        preOrder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以node为根的二叉树 进行中序遍历 有序遍历二分搜索树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        inOrder(node-&gt;left);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;node-&gt;key &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        inOrder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以node为根的二叉树 进行后续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        postOrder(node-&gt;left);</span><br><span class="line">        postOrder(node-&gt;right);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;node-&gt;key &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>三种遍历遍历的实现均为递归策略，根据二分搜索树的定义和中序遍历的规则可以实现二叉树有序遍历，而后续遍历的特点可以作为树销毁的过程</p>
</blockquote>
<blockquote>
<p>树销毁的实现，可以与后续遍历进行比较</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//销毁树 后序遍历的应用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            destroy(node-&gt;left);<span class="comment">//销毁左子树</span></span><br><span class="line">            destroy(node-&gt;right);   <span class="comment">//销毁右子树</span></span><br><span class="line">            <span class="keyword">delete</span>  node; node = <span class="literal">NULL</span>; <span class="comment">//删除节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><blockquote>
<p>看完深度优先遍历，那就看一下广度优先遍历，也就是层次遍历</p>
</blockquote>
<p><img src="/" alt="BFS" class="lazyload" data-src="/images/BST/tree20200320/tree8.gif"></p>
<blockquote>
<p>按逐层遍历每一个节点，最简单的方式就是借助一个队列把每一层信息加入进来</p>
</blockquote>
<blockquote>
<p>广度优先遍历实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广度优先遍历(BFS) 层次遍历-队列实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt; q; <span class="comment">//存放Node的队列</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123;  <span class="comment">//判断树空的情况</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Tree Null"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> ( !q.empty())&#123;</span><br><span class="line">            Node* node = q.front(); <span class="comment">//取出第一个值</span></span><br><span class="line">            q.pop(); <span class="comment">//将第一个值出队，以便遍历下一个值</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//打印key值</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) <span class="comment">//如果左节点存在加入左子树的节点</span></span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) <span class="comment">//如果右节点存在加入右子树的节点</span></span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="二分搜索树删除"><a href="#二分搜索树删除" class="headerlink" title="二分搜索树删除"></a>二分搜索树删除</h3><blockquote>
<p>删除节点，也是先来看看删除最大最小如何实现，最大最小节点上文也介绍了</p>
</blockquote>
<p><img src="/" alt="min" class="lazyload" data-src="/images/BST/tree20200320/tree9.gif"></p>
<blockquote>
<p>最小节点不存在左节点但存在右节点;</p>
</blockquote>
<p><img src="/" alt="max" class="lazyload" data-src="/images/BST/tree20200320/tree10.gif"></p>
<blockquote>
<p>最大节点不存在右节点但存在左节点;</p>
</blockquote>
<p><img src="/" alt="max" class="lazyload" data-src="/images/BST/tree20200320/tree11.gif"></p>
<blockquote>
<p>最大最小节点不存在左右子节点</p>
</blockquote>
<blockquote>
<p>对于这三种情况，最后一种直接将最后一个节点删除，前两种则需要将存在的一个节点替代最大最小节点</p>
</blockquote>
<blockquote>
<p>最大最小节点删除实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以node为根的二叉树 删除最小值</span></span><br><span class="line"><span class="function">Node* <span class="title">removeMin</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>) &#123;   <span class="comment">//如果左节点不存在，当前节点即最小</span></span><br><span class="line">        Node* right = node-&gt;right ; <span class="comment">//取用右节点代替</span></span><br><span class="line">        <span class="keyword">delete</span> node; node = <span class="literal">NULL</span>;<span class="comment">//删除节点 释放内存</span></span><br><span class="line">        <span class="keyword">return</span> right; <span class="comment">//返回右节点作为最小节点或者NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;left = removeMin(node-&gt;left); <span class="comment">//递归删除</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以node为根的二叉树 删除最大值</span></span><br><span class="line"><span class="function">Node* <span class="title">removeMax</span><span class="params">(Node* node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span>) &#123;   <span class="comment">//如果右节点不存在，当前节点即最大</span></span><br><span class="line">        Node* left = node-&gt;left ; <span class="comment">//取用左节点代替</span></span><br><span class="line">        <span class="keyword">delete</span> node; node = <span class="literal">NULL</span>;   <span class="comment">//删除节点 释放内存</span></span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">//返回左节点作为最小节点或者NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;right = removeMax(node-&gt;right); <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么删除任意一个节点会遇到的情况，除了上述存在但个子节点还在无节点，还存在两个节点均存在的情况</p>
</blockquote>
<p><img src="/" alt="remove" class="lazyload" data-src="/images/BST/tree20200320/tree12.gif"></p>
<blockquote>
<p>根据Hubbard Deletion思想的做法，可以从右子树中找到一个最小值，或者左子树中找到一个最大值来作为后继替换当前节点</p>
</blockquote>
<blockquote>
<p>删除节点具体实现</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以node为根的二叉树 删除Key节点</span></span><br><span class="line"><span class="function">Node* <span class="title">remove</span><span class="params">(Node* node,Key key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key)  <span class="comment">//左数查找</span></span><br><span class="line">        node-&gt;left = remove(node-&gt;left,key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)   <span class="comment">//右树查找</span></span><br><span class="line">        node-&gt;right = remove(node-&gt;right,key);</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//找到的情况</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span>)&#123;    <span class="comment">//左孩子为空以及左右孩子都为空</span></span><br><span class="line">            Node* right = node-&gt;right; <span class="comment">//右节点代替左节点的位置</span></span><br><span class="line">            <span class="keyword">delete</span> node; node = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right == <span class="literal">NULL</span>)&#123; <span class="comment">//右孩子为空</span></span><br><span class="line">            Node* left = node-&gt;left;<span class="comment">//左节点代替右节点的位置</span></span><br><span class="line">            <span class="keyword">delete</span> node; node = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理左右子树都存在的情况</span></span><br><span class="line">        Node* successor = <span class="keyword">new</span> Node(minimum(node-&gt;right)); <span class="comment">//找到（后继）右子树的最小值替换删除的节点（拷贝）</span></span><br><span class="line">        successor-&gt;right = removeMin(node-&gt;right);  <span class="comment">//替换节点指向删除右子树最小值后的右子树（已经用来替换的节点）</span></span><br><span class="line">        successor-&gt;left = node-&gt;left;   <span class="comment">//替换节点指向用来左子树</span></span><br><span class="line">        <span class="keyword">delete</span>  node; node = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> successor; <span class="comment">//返回新树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里实现二分搜索树最基本的常见操作(增删改查)，还有floor ceil rank select操作会不断更新，本文完整代码可以在本人gitee上找到：<a href="https://gitee.com/Vincent-Vic/DataOrganization/blob/master/BinarySearch/BinarySearchTree.h" target="_blank" rel="noopener">BST完整代码</a></p>
<p>欢迎各位大佬纠正错误</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>搜索树</tag>
        <tag>树</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>01-复杂度3 二分查找 (20分)</title>
    <url>/article/01-fu-za-du-3-er-fen-cha-zhao-20-fen/</url>
    <content><![CDATA[<h6 id="本题要求实现二分查找算法。"><a href="#本题要求实现二分查找算法。" class="headerlink" title="本题要求实现二分查找算法。"></a>本题要求实现二分查找算法。</h6><h5 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Position BinarySearch( List L, ElementType X );</span><br></pre></td></tr></table></figure>

<h5 id="其中List结构定义如下："><a href="#其中List结构定义如下：" class="headerlink" title="其中List结构定义如下："></a>其中List结构定义如下：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int Position;</span><br><span class="line">typedef struct LNode *List;</span><br><span class="line">struct LNode &#123;</span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; &#x2F;* 保存线性表中最后一个元素的位置 *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>L是用户传入的一个线性表，其中ElementType元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数BinarySearch要查找X在Data中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记NotFound。</p>
</blockquote>
<h4 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXSIZE 10</span><br><span class="line">#define NotFound 0</span><br><span class="line">typedef int ElementType;</span><br><span class="line"></span><br><span class="line">typedef int Position;</span><br><span class="line">typedef struct LNode *List;</span><br><span class="line">struct LNode &#123;</span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; &#x2F;* 保存线性表中最后一个元素的位置 *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">List ReadInput(); &#x2F;* 裁判实现，细节不表。元素从下标1开始存储 *&#x2F;</span><br><span class="line">Position BinarySearch( List L, ElementType X );</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    L &#x3D; ReadInput();</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;X);</span><br><span class="line">    P &#x3D; BinarySearch( L, X );</span><br><span class="line">    printf(&quot;%d\n&quot;, P);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 你的代码将被嵌在这里 *&#x2F;</span><br></pre></td></tr></table></figure>



<h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">12 31 55 89 101</span><br><span class="line">31</span><br></pre></td></tr></table></figure>

<h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">26 78 233</span><br><span class="line">31</span><br></pre></td></tr></table></figure>

<h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><img src="/" alt="二分实现" class="lazyload" data-src="/images/Base/pasted-1.png"></p>
<p>一图解千言，接下来再看看实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span>&#123;</span><br><span class="line">    Position P=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">//左边下标 从0开始</span></span><br><span class="line">    <span class="keyword">int</span> right = L-&gt;Last;  <span class="comment">//右边下标 从最后一个开始</span></span><br><span class="line">    <span class="keyword">int</span> middle = (left + right)/<span class="number">2</span>; <span class="comment">//找到列表的中间值</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123; <span class="comment">//当左右下标（上下界）查找区间</span></span><br><span class="line">        <span class="keyword">if</span>(L-&gt;Data[middle] &gt; X)&#123;  <span class="comment">//查找数据数据比当前小，说明这个值不可能存在右边，将右边向左边缩小，继续查找</span></span><br><span class="line">            right = middle<span class="number">-1</span>;        </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(L-&gt;Data[middle] &lt; X)  &#123;   <span class="comment">//查找数据比当前大，也可以说明这个值不会在左边，向右缩小，继续查找        </span></span><br><span class="line">            left = middle+<span class="number">1</span>;        </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(L-&gt;Data[middle] == X) &#123;    <span class="comment">//当前就是查找到的情况，记录下标</span></span><br><span class="line">            P = middle;            </span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        middle = (left + right)/<span class="number">2</span>;    <span class="comment">//每次查找对半</span></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(L-&gt;Data[middle] == X)  P = middle;    <span class="comment">//再次判断，为了确认是否找到</span></span><br><span class="line">    <span class="keyword">else</span>   P = NotFound;     <span class="comment">//没有找到，按题目要求返回</span></span><br><span class="line">    <span class="keyword">return</span> P;   <span class="comment">//返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/article/hello-world/</url>
    <content><![CDATA[<h1 id="Hello-第一篇文章"><a href="#Hello-第一篇文章" class="headerlink" title="Hello 第一篇文章"></a>Hello 第一篇文章</h1><h6 id="菜鸟选手也来写Blog了"><a href="#菜鸟选手也来写Blog了" class="headerlink" title="菜鸟选手也来写Blog了"></a>菜鸟选手也来写Blog了</h6><h6 id="我是Vincent-Vic-用最菜的方式划水"><a href="#我是Vincent-Vic-用最菜的方式划水" class="headerlink" title="我是Vincent Vic,用最菜的方式划水"></a>我是Vincent Vic,用最菜的方式划水</h6><h6 id="这个Blog-用来记录我的学习笔记，让自己习惯做笔记"><a href="#这个Blog-用来记录我的学习笔记，让自己习惯做笔记" class="headerlink" title="这个Blog 用来记录我的学习笔记，让自己习惯做笔记"></a>这个Blog 用来记录我的学习笔记，让自己习惯做笔记</h6><h4 id="简单算法，数据结构，C-，Java-都是我的学习目标"><a href="#简单算法，数据结构，C-，Java-都是我的学习目标" class="headerlink" title="简单算法，数据结构，C++，Java 都是我的学习目标"></a>简单算法，数据结构，C++，Java 都是我的学习目标</h4><h3 id="Stay-hungry-Stay-foolish！"><a href="#Stay-hungry-Stay-foolish！" class="headerlink" title="Stay hungry, Stay foolish！"></a>Stay hungry, Stay foolish！</h3>]]></content>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
</search>
